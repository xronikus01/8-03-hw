# Домашнее задание к занятию "`Репликация и масштабирование. Часть 2" - Гаран Степан

---

### Задание 1

### 1) Активный master-сервер и пассивный репликационный slave-сервер

**Преимущества:**
- **Простая и понятная архитектура:** запись выполняется только на master, реплика только принимает изменения → минимум конфликтов.
- **Отказоустойчивость:** при падении master можно переключиться на slave (failover), так как на нём есть актуальная копия данных.
- **Разгрузка по чтению:** часть SELECT-запросов (отчёты/аналитика) можно направлять на slave, снижая нагрузку на master.
- **Удобство обслуживания:** бэкапы/проверки/обновления можно выполнять на slave, меньше влияя на прод.

### 2) Master-сервер и несколько slave-серверов

**Преимущества:**
- **Горизонтальное масштабирование чтения:** SELECT-запросы распределяются по нескольким slave → растёт производительность при большом числе чтений.
- **Повышение доступности чтения:** при отказе одного slave чтение продолжается с других.
- **Гибкое разделение нагрузки:** разные slave можно использовать под разные типы нагрузки (витрина, отчёты, аналитика, бэкапы).
- **Проще наращивать ресурсы:** добавление нового slave часто быстрее и дешевле, чем постоянное вертикальное усиление одного сервера.

---

### Задание 2

Нужно спроектировать шардинг БД из 3 таблиц: **users**, **books**, **stores**.

---

#### 1) Вертикальный шардинг (vertical sharding)

Смысл: разделяем данные по смысловым доменам/подсистемам, чтобы разные части системы можно было масштабировать независимо.

Предлагаемое разбиение:
- **DB_Users**: таблица `users` (учётные записи, профили, персональные данные).
- **DB_Catalog**: таблица `books` (каталог книг, описания, цены, наличие).
- **DB_Stores**: таблица `stores` (магазины, адреса, регионы, расписания).

Плюсы:
- изоляция нагрузок (каталог читается часто, users — более транзакционный);
- проще разграничить доступы;
- можно масштабировать домены отдельно.

Минусы:
- JOIN между доменами делается сложнее (чаще на уровне приложения/сервисов).

---

#### 2) Горизонтальный шардинг (horizontal sharding)

Смысл: делим данные внутри одной сущности на несколько шардов по ключу.

**Шардирование users**
- Ключ: `user_id`
- Правило: `shard = user_id % N` (N — число шардов)
- Пример: `DB_Users_Shard_0..3` (4 шарда)

**Шардирование stores**
Варианты:
- по `store_id % N` (равномерно);
- или по региону (`region_id`) если нагрузка/данные логично делятся географически.

**Таблица books**
Варианты:
- если каталог общий и его важно держать целостным → оставить в одной БД и масштабировать чтение репликами;
- если каталог очень большой → шардировать по `book_id % N` (равномерно) или по категории (менее равномерно).

---

#### 3) Режимы работы серверов

Для каждой БД/шарда:
- **master** — принимает запись (INSERT/UPDATE/DELETE);
- **replica (read-only)** — обслуживает чтение (SELECT).

Распределение нагрузки:
- запись всегда в master;
- чтение по возможности с replica (через балансировку);
- при падении master возможен failover: promotion replica → новый master.

---

#### 4) Блок-схема размещения (что где расположено)

![Sharding diagram](img/task2/sharding-diagram.png)
---
